<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Sand Particles with Gaps</title>
  <style>
    html, body {
      margin: 0;
      overflow: hidden;
      background: #111;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
<canvas id="canvas"></canvas>

<!-- Matter.js -->
<script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>

<script>
  const {
    Engine, Render, Runner, World,
    Bodies, Body, Events, Mouse, Query
  } = Matter;

  const canvas = document.getElementById("canvas");
  const width = window.innerWidth;
  const height = window.innerHeight;

  const engine = Engine.create();
  const world = engine.world;

  const render = Render.create({
    canvas,
    engine,
    options: {
      width,
      height,
      background: '#111',
      wireframes: false,
      pixelRatio: window.devicePixelRatio,
    }
  });

  Render.run(render);
  Runner.run(Runner.create(), engine);

  // Стены
  const ground = Bodies.rectangle(width / 2, height + 20, width, 40, { isStatic: true });
  const wallLeft = Bodies.rectangle(-20, height / 2, 40, height, { isStatic: true });
  const wallRight = Bodies.rectangle(width + 20, height / 2, 40, height, { isStatic: true });
  World.add(world, [ground, wallLeft, wallRight]);

  // Положение мыши
  const mousePos = { x: -9999, y: -9999 };
  window.addEventListener("mousemove", e => {
    mousePos.x = e.clientX;
    mousePos.y = e.clientY;
  });

  // Песчинка с физическим и визуальным радиусом
  const createParticle = (x, y) => {
    const physicsRadius = 16;
    const visualRadius = 8.2;

    const body = Bodies.circle(x, y, physicsRadius, {
      restitution: 0.05,
      friction: 0.05,
      frictionAir: 0.01,
      render: {
        visible: false // отключаем стандартную отрисовку
      }
    });

    body.plugin.visualRadius = visualRadius;
    body.plugin.color = Math.random() > 0.5 ? "#ff0000" : "#ffffff";
    return body;
  };

  // Генерация песка
  const PARTICLE_COUNT = 500;
  for (let i = 0; i < PARTICLE_COUNT; i++) {
    const x = Math.random() * width;
    const y = -Math.random() * height;
    const p = createParticle(x, y);
    World.add(world, p);
  }

  // Оптимизированное отталкивание мыши
  Events.on(engine, "beforeUpdate", () => {
    const radius = 70;
    const strength = 0.03;

    const region = {
      min: { x: mousePos.x - radius, y: mousePos.y - radius },
      max: { x: mousePos.x + radius, y: mousePos.y + radius }
    };

    const bodies = Query.region(world.bodies, region);
    for (let body of bodies) {
      if (body.isStatic) continue;

      const dx = body.position.x - mousePos.x;
      const dy = body.position.y - mousePos.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < radius) {
        const force = (1 - dist / radius) * strength;
        const angle = Math.atan2(dy, dx);

        Body.applyForce(body, body.position, {
          x: Math.cos(angle) * force,
          y: Math.sin(angle) * force
        });
      }
    }
  });

  // Кастомная отрисовка с учётом визуального радиуса
  Events.on(render, "afterRender", () => {
    const ctx = render.context;
    for (const body of world.bodies) {
      if (body.circleRadius && body.plugin?.visualRadius) {
        ctx.beginPath();
        ctx.arc(body.position.x, body.position.y, body.plugin.visualRadius, 0, Math.PI * 2);
        ctx.fillStyle = body.plugin.color || "#fff";
        ctx.fill();
      }
    }
  });

</script>
</body>
</html>
